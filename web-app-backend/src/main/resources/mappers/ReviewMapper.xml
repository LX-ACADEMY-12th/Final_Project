<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.ReviewMapper">

	<!-- 리뷰 조회 -->
    <select id="findReviewsByTarget" resultType="com.example.demo.dto.ReviewResponseDTO">
	    SELECT
	        r.review_id AS reviewId,
	        r.target_type AS targetType, -- targetType이 전시면 targetId가 전시 id와 같다.
	        r.target_id AS targetId,
	        r.content,
	        r.rating,
	        r.created_at AS createdAt,
	        r.updated_at AS updatedAt,
	        r.user_id AS authorId,
	        -- "user" 테이블의 'name' 컬럼
	        u.name AS authorName,
	        -- "review" 테이블의 'like_count' 컬럼
	        r.like_count AS likeCount,
            -- user 테이블에서 photo_url을 authorProfileImageUrl로 가져옵니다.
            u.photo_url AS authorProfileImageUrl,
	        r.status
        FROM
	        review r
	    LEFT JOIN
	        "user" u ON r.user_id = u.user_id
	    WHERE
	        r.target_id = #{targetId} 
	        AND r.target_type = #{targetType}
	    ORDER BY
	        r.created_at DESC
       	LIMIT #{size} OFFSET #{offset}
	</select>
	
	<!-- 리뷰 목록에 페이지네이션을 하려면 리뷰를 세는 쿼리 필요 -->
	<select id="countReviewsByTarget" resultType="long">
        SELECT COUNT(*)
        FROM review
        WHERE 
            target_id = #{targetId}
        AND 
            target_type = #{targetType}
            AND status = 'ACTIVE'
    </select>

	<!-- 리뷰에 있는 사진 불러오기 -->
	<select id="findPhotosByReviewId" resultType="java.lang.String">
	    SELECT photo_url AS url 
	    FROM review_photo 
	    WHERE review_id = #{reviewId}
	</select>
	
	<!-- 해당 전시/ 장소에 대한 리뷰의 모든 사진 -->
	<select id="findAllPhotosByTarget" resultType="java.lang.String">
	    SELECT 
	        p.photo_url
	    FROM 
	        review r
	    JOIN 
	        review_photo p ON r.review_id = p.review_id
	    WHERE 
	        r.target_id = #{targetId}
	    AND 
	        r.target_type = #{targetType}
        AND r.status = 'ACTIVE'
	    ORDER BY 
	        r.created_at DESC,  p.sequence ASC      
    </select>
	
	<!-- PostgreSQL: RETURNING으로 PK 회수 -->
	<!-- 리뷰 추가 -->
    <insert id="insertReview"
        useGeneratedKeys="true"
        keyProperty="dto.reviewId"
        keyColumn="review_id">
	  INSERT INTO review (
	    user_id, target_type, target_id,
	    content, rating, created_at, updated_at, like_count, status
	  ) VALUES (
	    #{userId},
	    #{dto.targetType},
	    #{dto.targetId},
	    #{dto.content},
	    #{dto.rating},
	    CURRENT_TIMESTAMP,
	    CURRENT_TIMESTAMP,
	    0,
        'ACTIVE'
	  )
	  RETURNING review_id
	</insert>
    
	<!-- 리뷰 사진 추가 -->
    <insert id="insertReviewPhoto">
        INSERT INTO review_photo (
            review_id, photo_url, sequence
        ) VALUES (
            #{reviewId},
            #{photoUrl},
            #{sequence}
        )
    </insert>
    
    <!-- 리뷰에 좋아요 달기 -->
    <insert id="insertReviewLike">
    	INSERT INTO review_like (user_id, review_id, created_at)
    	VALUES (#{userId}, #{reviewId}, CURRENT_TIMESTAMP)
    </insert>
    
    <!--  리뷰에 단 좋아요 삭제 -->
    <delete id="deleteReviewLike">
    	DELETE FROM review_like
    	WHERE user_id = #{userId} AND review_id = #{reviewId}
    </delete>
    
    <!-- 리뷰에 달린 좋아요 수 업데이트 -->
    <update id="updateReviewLikeCount">
	    UPDATE review
	    SET like_count = like_count + #{amount}
	    WHERE review_id = #{reviewId}
	</update>
	
	<!-- 이미 좋아요를 누른 사람이 또 누르는지 확인하려고 -->
	<select id="existsReviewLike" resultType="int">
	    SELECT COUNT(*) 
	    FROM review_like
	    WHERE user_id = #{userId} AND review_id = #{reviewId}
	</select>
	
	<!-- 내가 단 리뷰 수정 -->
	<!-- 리뷰 수정 (작성자 본인만) -->
	<update id="updateReview" parameterType="map">
	  UPDATE review
	  SET content = #{dto.content},
	      rating  = #{dto.rating},
	      updated_at = CURRENT_TIMESTAMP
	  WHERE review_id = #{reviewId}
	    AND user_id   = #{userId}
	    AND status = 'ACTIVE'
	</update>
	
	<!-- 리뷰 수정시 사진 관련 -->
	<delete id="deletePhotosByReviewId" parameterType="long">
        DELETE FROM review_photo
        WHERE review_id = #{reviewId}
    </delete>
		
	<!-- 리뷰 삭제 (작성자 본인만) -->
	<delete id="deleteReview" parameterType="map">
	  DELETE FROM review
	  WHERE review_id = #{reviewId}
	    AND user_id   = #{userId}
	</delete>
	
	<!-- (관리자/시스템용) 사용자 체크 없이 리뷰 삭제 -->
	<delete id="adminDeleteReview" parameterType="long">
	  UPDATE review
	  SET status = 'DELETED_BY_ADMIN', updated_at = CURRENT_TIMESTAMP
	  WHERE review_id = #{reviewId}
	    AND status = 'ACTIVE'
	</delete>
	
	<!-- 다른 사용자 후기 신고 -->
	<!-- 신고 삽입/중복 체크/카운트 -->
	<!-- 중복이면 PK 충돌(duplicate key) 발생 -->
	<insert id="insertReviewReport" parameterType="map">
	  INSERT INTO review_report (review_id, reporter_user_id, created_at)
	  VALUES (#{reviewId}, #{reporterUserId}, CURRENT_TIMESTAMP)
	</insert>
	
	<!-- 신고 수가 임계치 이상일 때만 리뷰 삭제 (자식은 FK CASCADE로 자동) -->
	<!-- 자동으로 삭제됨 -->
	<update id="adminDeleteReviewIfReportedAtLeast" parameterType="map">
	  UPDATE review r
	  SET status = 'BLOCKED', updated_at = CURRENT_TIMESTAMP
	  WHERE r.review_id = #{reviewId}
	    AND r.status = 'ACTIVE' AND (
	      SELECT COUNT(*) FROM review_report rr
	      WHERE rr.review_id = r.review_id
	    ) >= #{threshold}
	</update>

    <delete id="deleteReviewReportByReviewId" parameterType="long">
        DELETE FROM review_report
        WHERE review_id = #{reviewId}
    </delete>

    <!-- 리뷰 메타 조회 -->
	<select id="findReviewMeta" parameterType="long" resultType="map">
	  SELECT
	    r.review_id   AS "reviewId",
	    r.target_id   AS "targetId",     <!-- ★ 따옴표 -->
	    r.target_type AS "targetType"    <!-- ★ 따옴표 -->
	  FROM review r
	  WHERE r.review_id = #{reviewId}
	    AND r.status != 'DELETED_BY_USER'
	</select>

	
	<!-- 타깃 집계 재계산(동적 분기) -->
	<update id="recomputeTargetStats" parameterType="map">
	  <choose>
	    <when test="targetType == 'science_place'">
		      UPDATE science_place sp
		      SET
	        total_reviews = (
	          SELECT COUNT(*) FROM review r
	          WHERE r.target_type = 'science_place'
	            AND r.target_id   = #{targetId}
	            AND r.status = 'ACTIVE'
	        ),
	        average_rating = COALESCE((
	          SELECT ROUND(AVG(r.rating)::numeric, 2)
	          FROM review r
	          WHERE r.target_type = 'science_place'
	            AND r.target_id   = #{targetId}
                AND r.status = 'ACTIVE'
	        ), 0),
          
          -- ⭐️ [추가] 사진 리뷰 개수 집계
          total_photo_reviews = (
            SELECT COUNT(DISTINCT r.review_id)
            FROM review r
            JOIN review_photo rp ON r.review_id = rp.review_id
            WHERE r.target_type = 'science_place'
              AND r.target_id = #{targetId}
              AND r.status = 'ACTIVE'
          )
          
	      	WHERE sp.place_id = #{targetId}
    	</when>

	    <when test="targetType == 'exhibition'">
	      UPDATE exhibition_hall AS eh
	      SET
	        total_reviews = (
	          SELECT COUNT(*) FROM review r
	          WHERE r.target_type = 'exhibition'
	            AND r.target_id   = #{targetId}
                AND r.status = 'ACTIVE'
	        ),
	        average_rating = COALESCE((
	          SELECT ROUND(AVG(r.rating)::numeric, 2)
	          FROM review r
	          WHERE r.target_type = 'exhibition'
	            AND r.target_id   = #{targetId}
                AND r.status = 'ACTIVE'
	        ), 0),
            
          -- 사진 리뷰 개수 집계
          total_photo_reviews = (
            SELECT COUNT(DISTINCT r.review_id)
            FROM review r
            JOIN review_photo rp ON r.review_id = rp.review_id
            WHERE r.target_type = 'exhibition'
              AND r.target_id = #{targetId}
              AND r.status = 'ACTIVE'
          )
            
	      WHERE eh.hall_id = #{targetId}
    	</when>
  	</choose>
	</update>

	<!-- 리뷰들 중에서, 특정 사용자(viewer)가 '좋아요'를 누른 리뷰의 ID 목록"**을 조회하는 기능 -->
	<!-- 대상(Target)과 사용자(User)를 기준으로 '좋아요'를 누른(Liked) 리뷰 ID(ReviewIds)를 찾는다(find)"는 의미 -->
	<select id="findLikedReviewIdsByTargetAndUser" resultType="long">
	  SELECT rl.review_id
	  FROM review_like rl
	  JOIN review r ON r.review_id = rl.review_id
	  WHERE r.target_type = #{targetType}
	    AND r.target_id   = #{targetId}
	    AND rl.user_id    = #{userId}
        AND r.status = 'ACTIVE'
	</select>

	
	<!-- 최신/순번 기준으로 사진 N장 ??-->
	<select id="findPhotosByReviewIds" resultType="map">
	  SELECT
	    review_id,
	    photo_url,
	    sequence
	  FROM review_photo
	  WHERE review_id IN
	  <foreach collection="reviewIds" item="reviewId" open="(" separator="," close=")">
	    #{reviewId}
	  </foreach>
	  ORDER BY review_id, sequence NULLS LAST, photo_id
	</select>
	
	
	<select id="findPhotoThumbnailsByTarget" resultType="com.example.demo.dto.PhotoThumbDTO">
	    SELECT 
	        R.review_id AS reviewId, 
	        RP.photo_url AS url
	    FROM 
	        review R
	    JOIN 
	        review_photo RP ON R.review_id = RP.review_id
	    WHERE 
	        R.target_id = #{targetId} 
	        AND R.target_type = #{targetType}
            AND r.status = 'ACTIVE'
	    ORDER BY 
	        R.created_at DESC  LIMIT #{limit}
	</select>

    <select id="findReportedReviews"
            resultType="com.example.demo.dto.ReportedReviewDTO">
        SELECT
            r.review_id AS reviewId,
            r.target_type AS targetType,
            r.target_id AS targetId,
            r.content,
            r.rating,
            r.created_at AS createdAt,
            r.user_id AS authorId,
            u.name AS authorName, -- 작성자 이름
            -- 신고 횟수 집계 (핵심 로직)
            COUNT(rr.review_id) AS reportCount,
            -- 대상 이름 조회 (전시 또는 답사 장소 이름)
            CASE r.target_type
                WHEN 'exhibition' THEN e.exhibition_name
                WHEN 'science_place' THEN sp.place_name
                ELSE '알 수 없음'
                END AS targetName
        FROM
            review r
                -- 1. 작성자 정보 JOIN
                INNER JOIN
            "user" u ON r.user_id = u.user_id
                -- 2. 신고 기록 정보 JOIN
                INNER JOIN
            review_report rr ON r.review_id = rr.review_id
                -- 3. 대상 이름 조회를 위한 LEFT JOIN (전시 테이블)
                LEFT JOIN
            exhibition e ON r.target_type = 'exhibition' AND r.target_id = e.exhibition_id
                -- 4. 대상 이름 조회를 위한 LEFT JOIN (답사 장소 테이블)
                LEFT JOIN
            science_place sp ON r.target_type = 'science_place' AND r.target_id = sp.place_id
        WHERE
            r.status = 'ACTIVE' GROUP BY
                                    r.review_id, u.name, e.exhibition_name, place_name
        -- 신고 횟수가 1회 이상인 것만 필터링
        HAVING
            COUNT(rr.review_id) > 0
        -- 가장 최근에 신고된 리뷰가 위로 오도록 정렬
        ORDER BY
            MAX(rr.created_at) DESC
    </select>
	
	


</mapper>